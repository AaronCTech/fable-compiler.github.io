<!doctype html>
<html>

<head>
  <title>Fable Docs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Josefin+Sans:400,300,600,700|Roboto+Mono">
  <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="/css/bulma.custom.css">
  <link rel="shortcut icon" href="/img/fable.ico" />
  <script src="https://cdn.polyfill.io/v2/polyfill.js?features=default,fetch"></script>
</head>

<body>
  <nav class="navbar"><div class="navbar-brand"><div class="navbar-item title is-4">Fable</div><div class="navbar-burger" data-target="navMenu"><span></span><span></span><span></span></div></div><div id="navMenu" class=" navbar-menu"><div class="navbar-start"><a class=" navbar-item" href="/">Home</a><a class=" navbar-item" href="/repl">REPL</a><a class=" navbar-item is-active" href="/docs">Docs</a><a class=" navbar-item" href="/samples-browser">Samples</a><a class=" navbar-item" href="/fableconf">FableConf</a></div><div class="navbar-end"><div class="navbar-item"><div class="field is-grouped"><p class="control"><a class="button twitter" href="https://twitter.com/FableCompiler"><span class="icon"><i class="fa fa-twitter"></i></span><span>Share the love!</span></a></p><p class="control"><a class="button github" href="https://gitter.im/fable-compiler/Fable"><span class="icon"><i class="fa fa-comments"></i></span><span>Chat</span></a></p><p class="control"><a class="button github" href="https://github.com/fable-compiler/Fable"><span class="icon"><i class="fa fa-github"></i></span><span>Contribute</span></a></p></div></div></div></div></nav>
  <div style="overflow-y:hidden;"><section class="fable-header"><img class="fable-logo" src="/img/fable_logo.png"/><div class="flex-1 has-text-right"><h1 class="title is-1">Docs</h1><h1 class="subtitle is-4">Straight to the point!</h1></div></section><div class="columns"><div class="column"></div><div class="column is-two-thirds samples-browser"><div class="content" style="margin:5px;"><p><h1 id="interacting-with-javascript">Interacting with JavaScript</h1></p>
<p><p>This page is structured as a reference document. For a more practical approach to Fable and JavaScript interop, please check <a href="https://medium.com/@zaid.naom/f-interop-with-javascript-in-fable-the-complete-guide-ccc5b896a59f">this great guide by Zaid Ajaj</a>.</p></p>
<p><h2 id="importing-javascript-code">Importing JavaScript code</h2></p>
<p><p>To use code from JS libraries first you need to import it into F#. For this Fables uses <a href="https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import">ES2015 imports</a>, which can be later transformed to other JS module systems like <code>commonjs</code> or <code>amd</code> by Babel.</p></p>
<p><p>There are two ways to declare ES2015 imports in the Fable: by using either the <strong>Import attribute</strong> or the <strong>import expressions</strong>. The <code>ImportAttribute</code> can decorate members, types or modules and works as follows:</p></p>
<pre><code class="lang-fsharp">// Namespace imports
[&lt;Import(&quot;*&quot;, from=&quot;my-module&quot;)&gt;]
// import * from &quot;my-module&quot;

// Member imports
[&lt;Import(&quot;myFunction&quot;, from=&quot;my-module&quot;)&gt;]
// import { myFunction } from &quot;my-module&quot;

// Default imports
[&lt;Import(&quot;default&quot;, from=&quot;express&quot;)&gt;]
// import Express from &quot;express&quot;
</code></pre>
<blockquote>
<p>If the value is globally accessible in JS, you can use the <code>Global</code> attribute with an optional name parameter instead.</p>
</blockquote>
<p>Unless you are decorating an abstract member, you can use <code>jsNative</code> as a placeholder for the body:</p>
<pre><code class="lang-fsharp">open Fable.Core.JsInterop

[&lt;Import(&quot;default&quot;, from=&quot;express&quot;)&gt;]
let Express: obj = jsNative
</code></pre>
<p>By opening <code>Fable.Core.JsInterop</code>, you will also have access to <strong>import expressions</strong>. These expressions are generic so be sure to make the type of the imported value explicit.</p>
<pre><code class="lang-fsharp">open Fable.Core.JsInterop

let buttons: obj = importAll &quot;my-lib/buttons&quot;
// import * as buttons from &quot;my-lib/buttons&quot;

// It works for function declarations too
let getTheme(x: int): IInterface = importDefault &quot;my-lib&quot;
// import getTheme from &quot;my-lib&quot;

let myString: string = importMember &quot;my-lib&quot;
// import { myString } from &quot;my-lib&quot;

// Use just `import` to make the member name explicit
// as with the ImportAttribute
let aDifferentName: string = import &quot;myString&quot; &quot;my-lib&quot;
// import { myString } from &quot;my-lib&quot;
</code></pre>
<h2 id="dynamic-typing">Dynamic typing</h2>
<p><a href="https://github.com/fable-compiler/Fable/blob/master/src/fable/Fable.Core/Fable.Core.fs">Fable.Core.JsInterop</a> implements the F# dynamic operators so you can easily access an object property by name (without static check)
as follows:</p>
<pre><code class="lang-fsharp">open Fable.Core.JsInterop

printfn &quot;Value: %O&quot; jsObject?myProperty

let pname = &quot;myProperty&quot;

printfn &quot;Value: %O&quot; jsObject?(pname) // Access with a string reference

jsObject?myProperty &lt;- 5 // Assignment is also possible
</code></pre>
<p>When you combine the dynamic operator with application, Fable will destructure tuple arguments as with normal method calls. These operations can also be chained to replicate JS fluent APIs.</p>
<pre><code class="lang-fsharp">let result = jsObject?myMethod(1, 2)
// var result = jsObject.myMethod(1, 2)

chart
    ?width(768.)
    ?height(480.)
    ?group(speedSumGroup)
    ?on(&quot;renderlet&quot;, fun chart -&gt;
        chart?selectAll(&quot;rect&quot;)?on(&quot;click&quot;, fun sender args -&gt;
            Browser.console.log(&quot;click!&quot;, args))
// chart
//     .width(768)
//     .height(480)
//     .group(speedSumGroup)
//     .on(&quot;renderlet&quot;, function (chart) {
//         return chart.selectAll(&quot;rect&quot;).on(&quot;click&quot;, function (sender, args) {
//             return console.log(&quot;click!&quot;, args);
//         });
//      });
</code></pre>
<blockquote>
<p>Note that in order to make this possible, the output of the <code>?</code> is an applicable value. If you don&#39;t want this behaviour, <code>unbox</code> or the <code>!!</code> dynamic cast operator: <code>let myValue: int = !!myObj?otherMethod(&quot;foo&quot;, &quot;bar&quot;)</code></p>
</blockquote>
<p>When you have to call a function with the <code>new</code> keyword in JS, use <code>createNew</code>.</p>
<pre><code class="lang-fsharp">open Fable.Core.JsInterop

let instance = createNew jsObject?myMethod(1, 2)
// var instance = new jsObject.myMethod(1, 2)
</code></pre>
<p>If you prefer the OOP style rather than the operators for dynamic typing, you can easily define your own extensions for the <code>obj</code> type.</p>
<pre><code class="lang-fsharp">open System
open Fable.Core
open Fable.Core.JsInterop

type Object with
  [&lt;Emit(&quot;$0[$1]&quot;)&gt;]
  member __.Item(idx: string): obj = jsNative
  [&lt;Emit(&quot;$0($1...)&quot;)&gt;]
  member __.Invoke([&lt;ParamArray&gt;] args: obj[]): obj = jsNative

let foo = obj()
let bar1 = foo.[&quot;b&quot;]
let bar2 = foo.Invoke(4, &quot;a&quot;)
</code></pre>
<h2 id="plain-old-javascript-objects">Plain Old JavaScript Objects</h2>
<p>To create a plain JS object (aka POJO), use <code>createObj</code>:</p>
<pre><code class="lang-fsharp">open FSharp.Core.JsInterop

let data =
    createObj [
        &quot;todos&quot; ==&gt; Storage.fetch()
        &quot;editedTodo&quot; ==&gt; None
        &quot;visibility&quot; ==&gt; &quot;all&quot;
    ]
</code></pre>
<p>You can also create a JS object from an interface by using <code>createEmpty</code> and then assigning manually:</p>
<pre><code class="lang-fsharp">type IMyInterface =
    abstract foo: string with get, set
    abstract bar: float with get, set

let x = createEmpty&lt;IMyInterface&gt; // var x = {}
x.foo &lt;- &quot;abc&quot;                    // x.foo = &quot;abc&quot;
x.bar &lt;- 8.5                      // val.bar = 8.5
</code></pre>
<p>It is also possible to instantiate a plain JS object in a type-safe manner by declaring an F# record with the <code>Pojo</code> attribute:</p>
<pre><code class="lang-fsharp">open Fable.Core

type [&lt;Pojo&gt;] MyRecord =
    { aNumber: int; aString: string }

let foo = { aNumber = 5; aString = &quot;bar&quot; }
// var foo = { aNumber: 5, aString: &quot;bar&quot; }
</code></pre>
<p>This is mainly useful to interact with JS libraries that expect a plain object (e.g., for configuration) instead of a class instance. But do not abuse this solution because records with <code>Pojo</code> attribute will miss features like members or reflection.</p>
<h2 id="foreign-interfaces">Foreign interfaces</h2>
<p>Defining a foreign interface is trivial: just create an F# interface and the compiler will call its properties or methods by name. However doing this may be a bit tedious for JS libraries with large APIs, so we better take advantage of <a href="http://definitelytyped.org">Typescript definition files</a> using <a href="https://www.npmjs.com/package/ts2fable">ts2fable</a>, a tool to translate <code>.d.ts</code> files into F# sources with Fable metadata. Check the <a href="https://www.npmjs.com/package/ts2fable">README file</a> for installation and usage instructions.</p>
<blockquote>
<p>Please note ts2fable is currently being updated and you may need to do some manual fixes after the automatic translation.</p>
</blockquote>
<p>You can find common definitions already parsed <a href="https://github.com/fable-compiler/fable-import">here</a>. These are already published in Nuget, where you can find more packages maintained by other contributors, usually <a href="https://www.nuget.org/packages?q=Fable.Import">prefixed by Fable.Import</a>. You can also find some other bindings and helpers in the <a href="https://github.com/kunjee17/awesome-fable#libraries">fable-awesome list</a>.</p>
<h2 id="special-attributes">Special attributes</h2>
<p>There are some attributes available in the <code>Fable.Core</code> namespace to ease the interaction with JS.</p>
<h3 id="emit-attribute">Emit attribute</h3>
<p>You can use the <code>Emit</code> attribute to decorate a function. Every call to the function will then be replaced <strong>inline</strong> by the content of the attribute with the placeholders <code>$0</code>, <code>$1</code>, <code>$2</code>... replaced by the arguments. For example, the following code will generate JavaScript as seen below.</p>
<pre><code class="lang-fsharp">open Fable.Core

[&lt;Emit(&quot;$0 + $1&quot;)&gt;]
let add (x: int) (y: string): float = jsNative

let result = add 1 &quot;2&quot;
</code></pre>
<pre><code class="lang-js">var result = 1 + &quot;2&quot;
</code></pre>
<p>When you don&#39;t know the exact number of arguments you can use the following syntax:</p>
<pre><code class="lang-fsharp">type Test() =
    [&lt;Emit(&quot;$0($1...)&quot;)&gt;]
    member __.Invoke([&lt;ParamArray&gt;] args: int[]): obj = jsNative
</code></pre>
<p>It&#39;s also possible to pass syntax conditioned to optional parameters.</p>
<pre><code class="lang-fsharp">type Test() =
    [&lt;Emit(&quot;$0[$1]{{=$2}}&quot;)&gt;]
    member __.Item with get(): float = jsNative and set(v: float): unit = jsNative

    // This syntax means: if second arg evals to true in JS print &#39;i&#39; and nothing otherwise
    [&lt;Emit(&quot;new RegExp($0,&#39;g{{$1?i:}}&#39;)&quot;)&gt;]
    member __.ParseRegex(pattern: string, ?ignoreCase: bool): Regex = jsNative
</code></pre>
<p>The content of <code>Emit</code> will actually be parsed by Babel so it will still be validated somehow. However, it&#39;s not advised to abuse this method, as the code in the template will remain obscure to Fable and may prevent some optimizations.</p>
<h3 id="erase-attribute">Erase attribute</h3>
<p>In TypeScript there&#39;s a concept of <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types">Union Types</a> which differs from union types in F#. The former are just used to statically check a function argument accepting different types. In Fable, they&#39;re translated as <strong>Erased Union Types</strong> whose cases must have one and only one single data field. After compilation, the wrapping will be erased and only the data field will remain. To define an erased union type, just attach the <code>Erase</code> attribute to the type. Example:</p>
<pre><code class="lang-fsharp">open Fable.Core

[&lt;Erase&gt;]
type MyErasedType =
    | String of string
    | Number of int

myLib.myMethod(String &quot;test&quot;)
</code></pre>
<pre><code class="lang-js">myLib.myMethod(&quot;test&quot;)
</code></pre>
<p><code>Fable.Core</code> already includes predefined erased types which can be used as follows:</p>
<pre><code class="lang-fsharp">open Fable.Core

type Test() =
    member x.Value = &quot;Test&quot;

let myMethod (arg: U3&lt;string, int, Test&gt;) =
    match arg with
    | U3.Case1 s -&gt; s
    | U3.Case2 i -&gt; string i
    | U3.Case3 t -&gt; t.Value
</code></pre>
<h3 id="stringenum-attribute">StringEnum attribute</h3>
<p>Similarly, in TypeScript it&#39;s possible to define <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types">String Literal Types</a> which are similar to enumerations with an underlying string value. Fable allows the same feature by using union types and the <code>StringEnum</code> attribute. These union types must not have any data fields as they will be compiled to a string matching the name of the union case.</p>
<p>By default, the compiled string will have the first letter lowered. If you want to prevent this or use a different text than the union case name, use the <code>CompiledName</code> attribute:</p>
<pre><code class="lang-fsharp">open Fable.Core

[&lt;StringEnum&gt;]
type MyStrings =
    | Vertical
    | [&lt;CompiledName(&quot;Horizontal&quot;)&gt;] Horizontal

myLib.myMethod(Vertical, Horizontal)
</code></pre>
<pre><code class="lang-js">myLib.myMethod(&quot;vertical&quot;, &quot;Horizontal&quot;)
</code></pre>
<h2 id="json-serialization">JSON serialization</h2>
<p>To make it easier to share types when you are also using F# on the server side, the functions <code>toJson</code> and <code>ofJson</code> are available in <code>Fable.Core.JsInterop</code> module. Unlike native JSON parsing in JavaScript, <code>ofJson</code> will <em>inflate</em> a proper instance of the target type if the string is well formed, that is, if it is the result of serializing the same type with <code>toJson</code> or <code>Fable.JsonConverter</code> (see below).</p>
<pre><code class="lang-fsharp">open Fable.Core.JsInterop

type Tree =
    | Leaf of int
    | Branch of Tree list
    member this.Sum() =
        match this with
        | Leaf i -&gt; i
        | Branch trees -&gt;
            trees |&gt; Seq.map (fun x -&gt; x.Sum()) |&gt; Seq.sum

let tree = Branch [Leaf 1; Leaf 2; Branch [Leaf 3; Leaf 4]]

let json = toJson tree
let tree2 = ofJson&lt;Tree&gt; json

let typeTest = (box tree2) :? Tree      // Type is kept
let sum = tree2.Sum()   // Prototype members can be accessed
</code></pre>
<p>On the server side, you can use <a href="https://www.newtonsoft.com/json">Newtonsoft.Json</a> + <a href="https://www.nuget.org/packages/Fable.JsonConverter/">Fable.JsonConverter</a>, as follows:</p>
<pre><code class="lang-fsharp">open Newtonsoft.Json

// Always use the same instance of the converter
// as it will create a cache to improve performance
let jsonConverter = Fable.JsonConverter() :&gt; JsonConverter

// Serialization
JsonConvert.SerializeObject(value, [|jsonConverter|])

// Deserialization
JsonConvert.DeserializeObject&lt;MyType&gt;(json, [|jsonConverter|])
</code></pre>
</div></div><div class="column"></div></div></div>
  <script>
    // Activate navbar burget button
    document.addEventListener('DOMContentLoaded', function () {
      var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
      if ($navbarBurgers.length > 0) {
        $navbarBurgers.forEach(function ($el) {
          $el.addEventListener('click', function () {
            var target = $el.dataset.target;
            var $target = document.getElementById(target);
            $el.classList.toggle('is-active');
            $target.classList.toggle('is-active');
          });
        });
      }
    });
  </script>
</body>

</html>